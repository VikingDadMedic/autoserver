$schema: http://json-schema.org/draft-06/schema#
$id: idlSchema
title: API engine IDL schema
description: Schema validating the API engine's IDL
type: object
properties:
  # Model definitions
  models:
    # Models are valid JSON schemas
    patternProperties:
      '.*':
        $ref: '#/definitions/modelSchema'
    # Check models names
    propertyNames:
      $ref: '#/definitions/validModelName'
  # Default operations
  operations:
    $ref: '#/definitions/operationsProperty'
  # Users can define anything under this property
  custom:
    type: object
  # Automatically generated, and used to validate e.g. `instanceof`
  modelNames:
    type: array
    items:
      type: string
# No custom property, except for `custom`
additionalProperties: false
definitions:
  # Main schema, for models under idl.models.modelName.*
  modelSchema:
    # Model schemas are an augmented version of a normal JSON schema
    anyOf:
    - type: object
      allOf:
      - $ref: '#/definitions/currentJsonSchema'
      - $ref: '#/definitions/futureJsonSchema'
      - $ref: '#/definitions/customJsonSchema'
    # JSON schemas can be booleans
    - type: boolean
  # Our additions to JSON schema
  customJsonSchema:
    properties:
      # Users can define anything under this property
      custom:
        type: object
      # Used to indicate an attribute is deprecated, and why
      deprecated:
        type: string
      # This attribute is added to distinguish between top-level models and the others, since they have different rules
      # It should not be specified by users though
      depthType:
        type: string
      properties:
        # Apply this schema recursively
        patternProperties:
          '.*':
            $ref: '#/definitions/modelSchema'
        # Attributes follow same naming convention as models
        propertyNames:
          $ref: '#/definitions/validModelName'
    # Different validations depending on whether model.depthType is 'model'
    if:
      required: [depthType]
      properties:
        depthType:
          const: model
    then:
      $ref: '#/definitions/topLevelModel'
    else:
      $ref: '#/definitions/nonTopLevelModel'
  # Only applies this to top-level schemas
  topLevelModel:
    properties:
      operations:
        $ref: '#/definitions/operationsProperty'
    propertyNames:
      anyOf:
      - $ref: '#/definitions/validPropertyNames'
      - enum: [operations]
  # Only applies this to non-top-level schemas
  nonTopLevelModel:
    properties:
      # Refers to a top-level model name
      instanceof:
        type: string
        enum:
          $data: '/modelNames'
    propertyNames:
      anyOf:
      - $ref: '#/definitions/validPropertyNames'
      - enum: [instanceof]
  # Validation of `operations` property, e.g. `operations: [find, createOne]`
  # This property restricts which operations a specific model can perform
  operationsProperty:
    type: array
    uniqueItems: true
    items:
      type: string
      enum: [find, findOne, create, createOne, replace, replaceOne, update, updateOne, upsert, upsertOne, delete, deleteOne]
    # One can only choose between find (conceptually "findOne" + "findMany") and "findOne". Same thing for other methods
    not:
      anyOf:
      - allOf: [contains: {enum: [find    ]}, contains: {enum: [findOne   ]}]
      - allOf: [contains: {enum: [delete  ]}, contains: {enum: [deleteOne ]}]
      - allOf: [contains: {enum: [update  ]}, contains: {enum: [updateOne ]}]
      - allOf: [contains: {enum: [upsert  ]}, contains: {enum: [upsertOne ]}]
      - allOf: [contains: {enum: [replace ]}, contains: {enum: [replaceOne]}]
      - allOf: [contains: {enum: [create  ]}, contains: {enum: [createOne ]}]
    # find or findOne has to be defined, because GraphQL requires at least one query operation
    contains: {enum: [find, findOne]}
  # Base list of valid property names
  # We are more restrictive than the JSON schema and forbid any unknown property name
  # The goal is to avoid typos and mistakes. Custom properties can be added in `custom`
  validPropertyNames:
    enum: [
      # Standard JSON schema properties
      $id, $schema, $ref, title, description, default, multipleOf, maximum, exclusiveMaximum, minimum,
      exclusiveMinimum, maxLength, minLength, pattern, additionalItems, items, maxItems, minItems, uniqueItems,
      contains, maxProperties, minProperties, required, additionalProperties, definitions, properties,
      patternProperties, dependencies, propertyNames, const, enum, type, format, allOf, anyOf, oneOf, not,
      # Future standard JSON schema properties
      examples, formatMaximum, formatMinimum, formatExclusiveMinimum, formatExclusiveMaximum, deepRequired,
      deepProperties, if, then, else,
      # Properties specific to this project
      custom, deprecated, depthType,
    ]
  validModelName:
    allOf:
    # Valid GraphQL identifier name, regular expression taken from spec
    # Additional restriction: lowercase-only
    - pattern: '^[_a-z][_0-9a-z]*$'
    # Should not start with __ as it is reserved for GraphQL introspection types
    - not:
        pattern: '^__'
  # Reuse standard JSON schema as a base
  currentJsonSchema:
    $ref: http://json-schema.org/draft-06/schema#
  # Future JSON standard
  futureJsonSchema:
    properties:
      examples:
        type: array
        items:
          type: string
      formatMaximum:
        type: string
      formatMinimum:
        type: string
      formatExclusiveMaximum:
        type: boolean
      formatExclusiveMinimum:
        type: boolean
      deepRequired:
        type: array
        items:
          type: string
          format: json-pointer
      deepProperties:
        type: object
        propertyNames:
          type: string
          format: json-pointer
        additionalProperties:
          $ref: '#/definitions/modelSchema'
      if:
        $ref: '#/definitions/modelSchema'
      then:
        $ref: '#/definitions/modelSchema'
      else:
        $ref: '#/definitions/modelSchema'
    dependencies:
      formatExclusiveMinimum: [formatMinimum]
      formatExclusiveMaximum: [formatMaximum]
      if: [then]
      then: [if]
      else: [then]
