### IDL FILE ###
# This file describes how the API should operate.
# It is purposely overly complex, as this example file aims to demonstrate all
# available features.
# A real production file should be much more concise.
# It is based on JSON schema v6 syntax, with some extra attributes
# Using this file, the API will automatically generate:
#  - HTTP server: body/query handling
#  - GraphQL server: endpoint, introspection, debugger, schema printing
#  - CRUD actions: find, create, replace, update, upsert, delete.
#    On a single model or several.
#  - CRUD arguments: filtering (including complex one), sorting, selecting
#  - nested actions, populating
#  - input and output validation
#  - default values, computed values, input/output transformation
#  - automatic attributes: created_time, updated_time, created_by, updated_by
#  - error handling
#  - logging
#  - routing

# IDL file version, required
$schema: tag:apiengine,2017:v1.0.0
# List of models
models:
  # Name of the model, used in routes, e.g. REST endpoints or GraphQL actions
  # Must only be lowercase ASCII letters, digits or underscore.
  # Cannot start with one digit or two underscores.
  pet:
    description: Cute animal
    # `Ã¬d` should always be required, and specified
    required: [id, name, photo_urls, friends]
    # Allowed commands for this model.
    # Defaults to top-level `commands` key (see it for further explanations)
    commands: [create, read, update, delete]
    # Custom property
    x-custom: anything
    properties:
      id:
        # Required for the moment.
        # Possible values: string, number, integer, boolean,
        # For the moment, cannot be an array
        description: Unique identifier of a pet
      name:
        type: string
        description: How to call a pet
        default: default does not work if required
        # Custom property
        x-custom: anything
        # Combinators JSON schema validation keywords
        oneOf:
        - pattern: '^[a-zA-Z]+$'
        - pattern: '[0-9]+$'
        allOf:
        - not:
            pattern: '^__'
        - not:
            pattern: '^[0-9]'
        anyOf:
        - pattern: '[a-z]'
        - pattern: '[A-Z]'
        - pattern: '[0-9]'
        if:
          pattern: '^super'
        then:
          pattern: '[a-z]'
        else:
          pattern: '[A-Z]'
      # Attributes follow the same naming restrictions as models
      weight:
        type: number
        # Description automatically used in documentation
        description: Corrolated to how much a pet has eaten
        # Deprecation is automatically used in documentation,
        # and gives warning messages
        deprecated: Let's stop measuring pet's weight
        default: 15
        # Number-specific JSON schema validation keywords
        minimum: 0.5
        maximum: 30
        exclusiveMinimum: 0.5
        exclusiveMaximum: 30
        # Can use floats
        multipleOf: 0.000001
        # Custom validation
        IsNotEqual: 10
        # Possible aliases for that attribute's name
        alias: old_weight_name
      is_overweight:
        type: boolean
        description: Has the pet being eating too much?
        # This JSON schema validation keyword can be applied to any type
        const: false
        default: false
      photo_urls:
        # Type defaults:
        #  - if `items` is present, type defaults to 'array'
        #  - if `model` is present, type defaults to 'object'
        #  - for top-level models, type defaults to 'object',
        #    and must be 'object'
        #  - otherwise, defaults to 'string'
        description: Sweet pictures of a pet
        # This is how to specify an array's elements
        items: {}
      skills:
        model: pet_skills
      tags:
        description: Tags applying to this pet
        # Array-specific JSON schema validation keywords
        items:
          type: string
          # String-specific JSON schema validation keywords
          minLength: 2
          maxLength: 200
          pattern: '^[a-zA-Z0-9 ]+$'
          # This JSON schema validation keyword can be applied to any type
          enum: [suspended, adorable]
        minItems: 0
        maxItems: 30
        uniqueItems: true
        default: []
      status:
        description: Has this pet been adopted
        # Applies transformations: status will be lowercased on write
        # Can be a function/JSL, including using $ or $$
        # Can be the `value` directly as a shortcut,
        # and does not have to be an array.
        transform:
        - value: ($.toLowerCase() + " " + $$.weight)
          # Optional test function. If false, the transform is not applied
          # Note that without `test`, $ can be undefined in `value`.
          test: (typeof $ === 'string')
          # In order to use $$.ATTRIBUTE, attributes must be specified here.
          # If those attributes have transforms, they will be calculated first.
          # This implies no circular dependencies should be defined.
          using: weight
        # Applied default values, on input or output
        default:
          $ref: default_value.js
      creator_key:
        description: Key of the user that created this pet
        # This means trying to write this attribute will be a noop,
        # but server might still return it.
        readOnly: true
        # compute is exactly like `transform`, except it is never persisted
        # in the database, while present in response. This implies:
        #  - JSL cannot use $ nor $$.CURRENT_ATTRIBUTE
        #  - `readOnly` true is implied
        #  - cannot be used together with any property that imply the attribute
        #    should be persisted, including `transform`, `default` or input
        #    validation
        compute: (String(moreRecursiveFunc()))
      best_friend:
        # This means this attribute is an instance of the `pet` model,
        # i.e. a foreign key
        # References can be recursive, e.g. here `pet` is the current model
        # Will actually copy the model's `id` property definition
        # (in case of conflict, current definition has priority)
        # Those "sub-models" to perform nested actions
        model: pet
        description: This pet's best friend
      # Array of foreign keys (i.e. n-1, 1-n and n-n relationships)
      # can also be specified
      friends:
        description: This pet's friends
        items:
          model: pet
      owners:
        items:
          type: object
          model: owner
      birth_date:
        # The following JSON schema validation keywords can be applied to
        # any type, although they are usually for strings
        format: date
        formatMinimum: 2000-01-01
        formatExclusiveMinimum: true
        formatMaximum: 2100-01-01
        formatExclusiveMinimum: false
        default: (birthDate)
  owner:
    # It is possible to reference/include local files or remote files (HTTP[S])
    # using standard JSON reference syntax
    # Circular references are supported
    # Included files will be merged with sibling properties
    $ref: owner.schema.yml
  pet_skills:
    $ref: pet_skills.schema.yml
# Actions can be:
#   - find: retrieve an element, similar to REST's GET
#   - create: create an element, similar to REST's POST.
#     `id` can be specified by client, or set by server.
#   - replace: completely replace an element, similar to REST's PUT
#   - update: partially update an element, similar to REST's PATCH
#   - upsert: if element exists, like "replace". Otherwise, like "create"
#   - delete: delete an element, similar to REST's DELETE
# Each action has two versions:
#   - singular: e.g. `findOne`, similar to REST's GET /models/ID
#   - plural: e.g. `findMany`, similar to REST's GET /models/
# By default, more singular and plural are allowed.
# To restrict to singular only, add `One`, e.g. `findOne`
# Actions can use the following arguments:
#   - `data`:
#      - in update, upsert, replace or create actions. Required by each of them
#      - must be an array of objects for all upsertMany, replaceMany and
#        createMany. Must be an object otherwise
#      - `id` is required for upsert and replace, optional for create,
#        not allowed for update
#      - contains the entities to modify or create
#      - can contain JSL, where $/$$ represents the current attribute/model
#        It will not be applied if the current attribute is null|undefined.
#   - `filter`:
#      - in find, delete and update actions.
#      - must be an object, whose keys are named after the models attributes
#      - can use JSL
#      - for findOne, deleteOne and updateOne, can only contain `id` key,
#        is required, and cannot use JSL
#      - used as a query filter, e.g. deleteMany { filter: { name: 'example' }}
#        remove all entities with `name` 'example'
#   - `order_by`
#      - in all *Many actions. Never required
#      - must be a comma-separated list of attributes, optionally prefixed
#        by + or -, e.g. 'name-,id'
#      - orders server response according to the specified attributes.
#        Default order is +, i.e. ascending
#   - `page_size` {integer}
#      - in findMany, deleteMany or updateMany
#      - defaults to server option defaultPageSize (default: 100)
#      - pagination size.
#      - 0 disables pagination.
#      - maximum is server option maxPageSize (default: 100)
#   - `before|after` {string}
#      - in findMany
#      - retrieves previous|next pagination batch,
#        using the previous response's 'token'
#      - use '' for the start or the end
#      - cannot be used together with `filter` nor `order_by`.
#   - `page` {integer}
#      - in findMany
#      - page number, for pagination, starting at 1
#      - cannot be used together with `before|after`
# Possible settings:
#   - `noOutput` {boolean}
#      - if true, the action will modify the database, but return an empty
#        response
#      - defaults to true for `delete`, false otherwise
#      - this can also be set for all the actions using:
#         - Prefer: return=minimal HTTP request header
#   - `dryRun` {boolean}
#      - in all actions except find. never required
#      - if true, the action will not modify the database,
#        but the return value will be the same as if it did
# JSL is a restricted syntax of JavaScript:
#   - any string that is surrounded by parenthesis will be interpreted as JSL,
#     except if first parenthesis is escaped:
#      - this is JSL: '(1 + 1)'
#      - this is not JSL: '\(1 + 1)'
#   - it can be used in `filter` (for findMany, updateMany or deleteMany),
#     and in transforms|compute|default
#   - at the moment, any JavaScript is allowed, but this will be restricted
#     (for filters only) in the future for security and performance reasons
#   - it can use parameters:
#      - they are divided into several groups:
#         - helpers
#         - "protocol parameters"
#            - $PROTOCOL {string} - possible values: 'http' only
#            - $NOW {string} - current date and time
#            - $IP {string} - request IP
#            - $REQUEST_ID {string} - UUID identifying the current request
#            - $PARAMS {object} - all params
#            - $SETTINGS {object} - all settings
#         - "operation parameters":
#            - $OPERATION {string} - possible values: 'graphql', 'graphiql',
#              'graphqlprint'
#         - "action parameters":
#            - $MODEL {string} - name of the model
#            - $ARGS {object} - arguments passed by client to the specific
#              action
#         - "command parameters":
#            - $COMMAND {string} - current command, among 'create', 'read',
#              'update' or 'delete'
#         - "database parameters":
#            - $ {any} - value of current attribute,
#              e.g. { filter: { name: '$ !== "John"' } }
#              checks whether model.name !== 'John'
#            - $$ {object} - current model (input or output),
#              e.g. { filter: { name: '$ === $$.first_name' } }
#              checks whether model.name === model.first_name
#         - "helpers parameters" (only available in inline helpers):
#            - $1, $2, etc. {any} - position parameter when firing
#              the helper function
#         - "validation parameters" (only available in validation keywords):
#            - $EXPECTED {any} - value passed to the validation rule
#      - restrictions:
#         - arg.filter|data can only use $ and $$ parameters
#           One can expose some helpers using `exposeTo` though (see below)
#      - not every information is available as a parameter, following the
#        principles:
#         - should encourage agnosticism, e.g. prefer exposing $COMMAND over
#           $ACTION
#         - should hide implementation details
# Default `commands` values for each model
# If unspecified, is all commands but deleteMany
commands: [create, read, update, delete]
# Helpers are functions that can be used in any JSL.
# Their argument is passed as parameters $1, $2, etc. in inline
# functions
# They must be pure functions
# Helpers can be an array of objects (which are merged), or a single object
# Helpers inherit the JSL parameters from the function that calls them
helpers:
  # Helpers use function/JSL themselves
  - myMathFunc: (($1 * $2) + ($3 * $4))
    exampleFunction: '(myMathFunc(1, 10, 100, 2) + myOtherMathFunc({ numA: 1, numB: 10, numC: 100, numD: 2 }))'
    recursive_func: (exampleFunction())
    # Since this function uses $OPERATION, caller must have access to this
    # parameter
    moreRecursiveFunc: (recursive_func() + TestConstant + $OPERATION)
    # Constant
    birthDate:
      value: 2005-01-01
      # By default, helpers are not available to arg.filter|data
      # But they can be exposed with the following property
      exposeTo: [filter, data]
    # One can require JavaScript files (Node.js)
    myOtherMathFunc:
      value:
        $ref: math_func.js
      # Pass JSL parameters as first argument to non-inline function
      useParams: true
      exposeTo: [data]
    # Dummy constant
    user: '(({ id: "1" }))'
  # One can require entire libraries.
  - $ref: underscore.string
  - $ref: lodash
  # One can require sets of constants
  - $ref: constants.json
# Plugins are functions that take `idl` as input, and returns a modified
# IDL as output.
# Use cases can be: adding a attribute to each model,
# extending core functionalities, etc.
# The system adds by default some builtin plugins, which can be disabled.
plugins:
  - plugin:
      $ref: test_plugin.js
    # Passed to the plugin function
    opts:
      exampleOption: true
    # True by default, more useful for builtin plugins
    # enabled: true
  # Builtin plugins are specified as a string, and run by default
  # - plugin: timestamp
  - plugin: author
    # Defines how to retrieve current user, so it can be used by updated_by
    # and created_by attributes
    opts:
      # user: (user())
      model: owner
# Custom validation keywords, to use on models' attributes
validation:
  IsNotEqual:
    # Validation function.
    # Must return true for success, anything else for failure
    # Must be a function/JSL
    test: ($ !== $EXPECTED)
    # Error message
    # Can be a function/JSL
    message: (`must not be equal to ${$EXPECTED}`)
    # Can restrict when the validation will be applied, using JSON schema types
    type: [number, integer]
# No specific semantics, but can be used by $ref
definitions:
  dummyDefinition:
    type: object
# Custom property
x-custom: anything
