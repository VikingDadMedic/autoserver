### IDL FILE ###
# This file describes how the API should operate.
# It is purposely overly complex, as this example file aims to demonstrate all available features.
# A real production file should be much more concise.
# It is based on JSON schema v6 syntax, with some extra attributes
# Using this file, the API will automatically generate:
#  - HTTP server: body/query handling
#  - GraphQL server: endpoint, introspection, debugger, schema printing
#  - CRUD actions: find, create, replace, update, upsert, delete. On a single model or several.
#  - CRUD arguments: filtering, sorting, selecting
#  - nested actions, populating
#  - input and output validation
#  - error handling
#  - logging
#  - routing

# IDL file version, required
$schema: tag:apiengine,2017:v1.0.0
# List of models
models:
  # Name of the model, used in routes, e.g. REST endpoints or GraphQL methods
  # Must only be lowercase ASCII letters, digits or underscore. Cannot start with one digit or two underscores.
  pet:
    description: Cute animal
    # `Ã¬d` should always be required, and specified
    required: [id, name, photo_urls, friends]
    # Allowed actions for this model.
    # Defaults to top-level `actions` key (see it for further explanations)
    actions: [find, create, replace, update, upsert, delete]
    # Custom property
    x-custom: anything
    properties:
      id:
        # Required for the moment. Possible values: string, number, integer, boolean,
        # For the moment, cannot be an array
        description: Unique identifier of a pet
      name:
        type: string
        description: How to call a pet
        default: default does not work if required
        # Custom property
        x-custom: anything
        # Combinators JSON schema validation keywords
        oneOf:
        - pattern: '^[a-zA-Z]+$'
        - pattern: '[0-9]+$'
        allOf:
        - not:
            pattern: '^__'
        - not:
            pattern: '^[0-9]'
        anyOf:
        - pattern: '[a-z]'
        - pattern: '[A-Z]'
        - pattern: '[0-9]'
        if:
          pattern: '^super'
        then:
          pattern: '[a-z]'
        else:
          pattern: '[A-Z]'
      # Attributes follow the same naming restrictions as models
      weight:
        type: number
        # Description automatically used in documentation
        description: Corrolated to how much a pet has eaten
        # Deprecation is automatically used in documentation, and gives warning messages
        deprecated: Let's stop measuring pet's weight
        default: 15
        # Number-specific JSON schema validation keywords
        minimum: 0.5
        maximum: 30
        exclusiveMinimum: 0.5
        exclusiveMaximum: 30
        # Can use floats
        multipleOf: 0.000001
      is_overweight:
        type: boolean
        description: Has the pet being eating too much?
        # This JSON schema validation keyword can be applied to any type
        const: false
        default: false
      photo_urls:
        # Type defaults:
        #  - if `items` is present, type defaults to 'array'
        #  - if `model` is present, type defaults to 'object'
        #  - for top-level models, type defaults to 'object', and must be 'object'
        #  - otherwise, defaults to 'string'
        type: array
        description: Sweet pictures of a pet
        # This is how to specify an array's elements
        items: {}
      skills:
        model: pet_skills
      tags:
        description: Tags applying to this pet
        # Array-specific JSON schema validation keywords
        items:
          type: string
          # String-specific JSON schema validation keywords
          minLength: 2
          maxLength: 200
          pattern: '^[a-zA-Z0-9 ]+$'
        contains:
          # This JSON schema validation keyword can be applied to any type
          enum: [suspended, adorable]
        minItems: 0
        maxItems: 30
        uniqueItems: true
        default: []
      status:
        description: Has this pet been adopted
        # Applies transformations: status will be stored lowercase in database, but returned uppercase to client
        # JSL can be used
        # This can be used to add compatibility layers, computed attributes, etc.
        transform: $.toLowerCase()
        transformOut: $.toUpperCase()
        # Applied default values, on input or output
        default:
        # Arrays are handled like a switch statement, i.e. only the first matching is used. Can be used for transforms too.
        - $name === "Dog" ? "happy"
        - $name === "Cat" ? "grumpy"
        defaultOut: $name + ' status'
        # By defaults, transforms must be idempotent, but this can be turned off
        idempotent: true
      creator_ip:
        description: IP of the user that created this pet
        # read-only attribute cannot be set by the client, but can be returned by the server
        # They can still be set by the server, e.g. using defaults and transforms, allowing server-side computed attributes
        # This can also be used if an attribute is deprecated, and we want to restrict clients from setting it, but
        # want to still allow them to read it
        readOnly: true
        # compute sets the value of an attribute.
        # The value provided by the user will be ignored, i.e. 'compute' implies `readOnly: true`
        # As opposed to `default`, this will also be set during update actions.
        # JSL can be used.
        # default and transforms can still be used (are performed afterwards).
        compute: $IP
        # Same for output. It is useless in this case, but used for illustration.
        computeOut: $IP
      best_friend:
        # This means this attribute is an instance of the `pet` model, i.e. a foreign key
        # References can be recursive, e.g. here `pet` is the current model
        # Will actually copy the model's `id` property definition (in case of conflict, current definition has priority)
        # Those "sub-models" to perform nested actions
        model: pet
        description: This pet's best friend
      # Array of foreign keys (i.e. n-1, 1-n and n-n relationships) can also be specified
      friends:
        description: This pet's friends
        items:
          model: pet
      owners:
        items:
          type: object
          model: owner
      birth_date:
        # The following JSON schema validation keywords can be applied to any type, although they are usually for strings
        format: date
        formatMinimum: '2000-01-01'
        formatExclusiveMinimum: true
        formatMaximum: '2100-01-01'
        formatExclusiveMinimum: false
  owner:
    # It is possible to reference/include local files or remote files (HTTP[S]) using standard JSON reference syntax
    # Circular references are supported
    # Included files will be merged with sibling properties
    $ref: examples/owner.schema.yml
  pet_skills:
    $ref: examples/pet_skills.schema.yml
# Default `actions` values for each model
# If unspecified, is all actions but deleteMany
# Actions can be:
#   - find: retrieve an element, similar to REST's GET
#   - create: create an element, similar to REST's POST. `id` can be specified by client, or set by server.
#   - replace: completely replace an element, similar to REST's PUT
#   - update: partially update an element, similar to REST's PATCH
#   - upsert: if element exists, like "replace". Otherwise, like "create"
#   - delete: delete an element, similar to REST's DELETE
# Each action has two versions:
#   - singular: e.g. `findOne`, similar to REST's GET /models/ID
#   - plural: e.g. `findMany`, similar to REST's GET /models/
# By default, more singular and plural are allowed. To restrict to singular only, add `One`, e.g. `findOne`
# Actions can use the following arguments:
#   - `data`:
#      - in update, upsert, replace or create actions. Required by each of them
#      - must be an array of objects for all upsertMany, replaceMany and createMany. Must be an object otherwise
#      - `id` is required for upsert and replace, optional for create, not allowed for update
#      - contains the entities to modify or create
#   - `filter`:
#      - in find, delete and update actions.
#      - must be an object, whose keys are named after the models attributes
#      - for findOne, deleteOne and updateOne, can only contain `id` key, is required, and cannot use JSL
#      - used as a query filter, e.g. deleteMany { filter: { name: 'example' } } remove all entities with `name` 'example'
#   - `order_by`
#      - in all *Many actions. Never required
#      - must be a comma-separated list of attributes, optionally prefixed by + or -, e.g. 'name-,id'
#      - orders server response according to the specified attributes. Default order is +, i.e. ascending
# JSL is a restricted syntax of JavaScript:
#   - it can be only used in `filter` (for findMany, updateMany or deleteMany) at the moment,
#     but will be added to other parts
#   - at the moment, any JavaScript is allowed, but this will be restricted in the future for security and performance reasons
#   - it can use variables:
#      - $NOW {string} - current date and time
#      - $IP {string} - request IP
#      - $ACTION {string} - current action, e.g. 'find' or 'create'
#      - $PARAMS {object} - contains all request parameters: query strings, (application-namespaced) HTTP headers
#      - $ {any} - value of current attribute, e.g. { filter: { name: '$ !== "John"' } } checks whether model.name !== 'John'
#      - $attribute {any} - value of a given attribute, e.g. { filter: { name: '$ === $first_name' } }
#        checks whether model.name === model.first_name
#   - any string that use at least one variable will be interpreted as JSL
actions: [find, create, replace, update, upsert, delete]
# No specific semantics, but can be used by $ref
definitions:
  dummyDefinition:
    type: object
# Custom property
x-custom: anything
