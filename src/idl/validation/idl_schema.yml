$schema: http://json-schema.org/draft-06/schema#
$id: idl_schema_v1
title: API engine IDL schema
description: Schema validating the API engine's IDL
type: object
required: [$schema, models]
properties:
  # Versioning
  $schema:
    type: string
    pattern: '^tag:apiengine,[0-9]+:v1\.[0-9]+\.[0-9]+$'
  # Model definitions
  models:
    # Models are valid JSON schemas
    additionalProperties:
      $ref: '#/definitions/modelObjectSchema'
    # Check models names
    propertyNames:
      $ref: '#/definitions/validModelName'
  # Default operations
  operations:
    $ref: '#/definitions/operationsProperty'
  # Standard JSON schema `definitions` can be used at the root
  definitions:
    type: object
    additionalProperties:
      $ref: '#/definitions/modelSchema'
    default: {}
  # Automatically generated, and used to validate e.g. `model`
  modelNames:
    type: array
    items:
      type: string
      hasPlural: true
# Users can define anything under properties named x-*
patternProperties:
  '^x-': true
# No custom property, except for `x-*`
additionalProperties: false
definitions:
  # Model schemas are an augmented version of a normal JSON schema
  modelObjectSchema:
    type: object
    allOf:
    - $ref: '#/definitions/currentJsonSchema'
    - $ref: '#/definitions/futureJsonSchema'
    - $ref: '#/definitions/customJsonSchema'
  # Main schema, for models under idl.models.modelName.*
  modelSchema:
    anyOf:
    - $ref: '#/definitions/modelObjectSchema'
    # JSON schemas can be booleans
    - type: boolean
  # Our additions to JSON schema
  customJsonSchema:
    properties:
      # Used to indicate an attribute is deprecated, and why
      deprecated:
        type: string
      # This attribute is added to distinguish between top-level models and the others, since they have different rules
      # It should not be specified by users though
      depthType:
        type: string
      # All spec-defined formats are allowed. We are stricter than the spec, as custom formats are forbidden.
      format:
        enum: [regex, date-time, date, time, email, hostname, ipv4, ipv6, uri, uri-reference, json-pointer,
          relative-json-pointer]
      properties:
        # Apply this schema recursively
        additionalProperties:
          $ref: '#/definitions/modelObjectSchema'
        # Attributes follow same naming convention as models
        propertyNames:
          $ref: '#/definitions/validModelName'
    # Different validations depending on whether model.depthType is 'model'
    if:
      required: [depthType]
      properties:
        depthType:
          const: model
    then:
      $ref: '#/definitions/topLevelModel'
    else:
      $ref: '#/definitions/nonTopLevelModel'
  # Only applies this to top-level schemas
  topLevelModel:
    # Must have a `required` property
    required: [required, properties]
    properties:
      operations:
        $ref: '#/definitions/operationsProperty'
      # `required` property must at least contain `id`
      required:
        contains:
          enum: [id]
      # Must have an `id`
      properties:
        required: [id]
    propertyNames:
      anyOf:
      - $ref: '#/definitions/validPropertyNames'
      - enum: [operations]
  # Only applies this to non-top-level schemas
  nonTopLevelModel:
    properties:
      # Refers to a top-level model name
      model:
        type: string
        enum:
          $data: '/modelNames'
    propertyNames:
      anyOf:
      - $ref: '#/definitions/validPropertyNames'
      - enum: [model]
  # Validation of `operations` property, e.g. `operations: [find, createOne]`
  # This property restricts which operations a specific model can perform
  operationsProperty:
    type: array
    uniqueItems: true
    items:
      type: string
      enum: [find, findOne, create, createOne, replace, replaceOne, update, updateOne, upsert, upsertOne, delete, deleteOne]
    # One can only choose between find (conceptually "findOne" + "findMany") and "findOne". Same thing for other methods
    not:
      anyOf:
      - allOf: [contains: {enum: [find    ]}, contains: {enum: [findOne   ]}]
      - allOf: [contains: {enum: [delete  ]}, contains: {enum: [deleteOne ]}]
      - allOf: [contains: {enum: [update  ]}, contains: {enum: [updateOne ]}]
      - allOf: [contains: {enum: [upsert  ]}, contains: {enum: [upsertOne ]}]
      - allOf: [contains: {enum: [replace ]}, contains: {enum: [replaceOne]}]
      - allOf: [contains: {enum: [create  ]}, contains: {enum: [createOne ]}]
    # find or findOne has to be defined, because GraphQL requires at least one query operation
    contains: {enum: [find, findOne]}
  # Base list of valid property names
  # We are more restrictive than the JSON schema and forbid any unknown property name
  # The goal is to avoid typos and mistakes. Custom properties can be added as `x-*`
  validPropertyNames:
    anyOf:
    - enum: [
      # Standard JSON schema properties
      $id, $schema, $ref, title, description, default, multipleOf, maximum, exclusiveMaximum, minimum,
      exclusiveMinimum, maxLength, minLength, pattern, items, maxItems, minItems, uniqueItems,
      contains, maxProperties, minProperties, required, additionalProperties, definitions, properties,
      patternProperties, dependencies, propertyNames, const, enum, type, format, allOf, anyOf, oneOf, not,
      # Future standard JSON schema properties
      examples, formatMaximum, formatMinimum, formatExclusiveMinimum, formatExclusiveMaximum, if, then, else,
      # Properties specific to this project
      deprecated, depthType,
    ]
    # Users can define anything under property named x-*
    - pattern: '^x-*'
  validModelName:
    allOf:
    # Valid GraphQL identifier name, regular expression taken from spec
    # Additional restriction: lowercase-only
    - pattern: '^[_a-z][_0-9a-z]*$'
    # Should not start with __ as it is reserved for GraphQL introspection types
    - not:
        pattern: '^__'
  # Reuse standard JSON schema as a base
  currentJsonSchema:
    # See the file named `json-schema-draft-06.yml` in same directory
    $ref: http://json-schema.org/draft-06/schema#
  # Future JSON standard
  futureJsonSchema:
    properties:
      examples:
        type: array
        items:
          type: string
      formatMaximum:
        type: string
      formatMinimum:
        type: string
      formatExclusiveMaximum:
        type: boolean
      formatExclusiveMinimum:
        type: boolean
      if:
        $ref: '#/definitions/modelSchema'
      then:
        $ref: '#/definitions/modelSchema'
      else:
        $ref: '#/definitions/modelSchema'
    dependencies:
      formatExclusiveMinimum: [formatMinimum]
      formatExclusiveMaximum: [formatMaximum]
      if: [then]
      then: [if]
      else: [then]
