$schema: http://json-schema.org/draft-06/schema#
$id: idl_schema_v1
title: API engine IDL schema
description: Schema validating the API engine's IDL
type: object
required: [$schema, models]
properties:
  # Versioning
  $schema:
    type: string
    pattern: '^tag:apiengine,[0-9]+:v1\.[0-9]+\.[0-9]+$'
  # Model definitions
  models:
    # Models are valid JSON schemas
    additionalProperties:
      allOf:
      - $ref: '#/definitions/topLevelModel'
      - properties:
          properties:
            # For models' attributes
            additionalProperties:
              $ref: '#/definitions/attributeSchema'
            # Attributes follow same naming convention as models
            propertyNames:
              $ref: '#/definitions/validModelName'
    # Check models names
    propertyNames:
      $ref: '#/definitions/validModelName'
  # Default actions
  actions:
    $ref: '#/definitions/actionsProperty'
  # Custom functions that can be used in JSL
  helpers:
    type: object
    properties:
      libraries:
        $ref: '#/definitions/librariesProperty'
    propertyNames:
      allOf:
      - pattern: '^[a-zA-Z_][0-9a-zA-Z_]*$'
      # system-defined helpers use THIS_CASE, so we forbid it for user-defined helpers for forward compatibility
      - not:
          pattern: '^[A-Z_]+$'
  # Custom variables that can be used in JSL
  variables:
    type: object
    properties:
      libraries:
        $ref: '#/definitions/librariesProperty'
    propertyNames:
      allOf:
      - pattern: '^\$[a-zA-Z_][0-9a-zA-Z_]*$'
      # system-defined variables use $THIS_CASE, so we forbid it for user-defined variables for forward compatibility
      - not:
          pattern: '^\$[A-Z_]+$'
  # Functions that modifies IDL definition
  plugins:
    type: array
    items:
      typeof: object
      properties:
        plugin:
          anyOf:
          - typeof: function
          - type: string
            enum: [a]
        enabled:
          typeof: boolean
        opts: {}
      additionalProperties: false
  # Custom validation keywords
  validation:
    type: object
    additionalProperties:
      type: object
      properties:
        test:
          $ref: '#/definitions/jsl'
        # Error messages can either be a string, or JSL
        message:
          type: string
          # Convention: error message must start with "must"
          anyOf:
          - not:
              $ref: '#/definitions/jsl'
            pattern: ^must\s
          - anyOf:
            - pattern: ^\("must\s.*"\)$
            - pattern: ^\('must\s.*'\)$
            - pattern: ^\(`must\s.*`\)$
        type:
          $ref: '#/definitions/jsonSchemaType'
      additionalProperties: false
    # Must start with uppercase letter to avoid naming conflict with other attributes, and ensure forward compatibility
    propertyNames:
      pattern: '^[A-Z][a-zA-Z0-9]*$'
  # Let user decide how to retrieve current user, which is used by created_by and updated_by
  users:
    type: object
    properties:
      id:
        type: string
      model:
        type: string
        enum:
          $data: '/modelNames'
    additionalProperties: false
  # Standard JSON schema `definitions` can be used at the root
  definitions:
    type: object
    additionalProperties:
      $ref: '#/definitions/generalSchema'
    default: {}
  # Automatically generated, and used to validate e.g. `model`
  modelNames:
    type: array
    items:
      type: string
      hasPlural: true
  # Automatically generated, and used to validate custom validation keywords
  customValidationNames:
    type: array
    items:
      type: string
# Users can define anything under properties named x-*
patternProperties:
  '^x-': true
# No custom property, except for `x-*`
additionalProperties: false
definitions:
  # Main schema
  generalSchema:
    anyOf:
    - $ref: '#/definitions/generalObjectSchema'
    # JSON schemas can be booleans
    - type: boolean
  # General schemas are an augmented version of a normal JSON schema
  generalObjectSchema:
    type: object
    allOf:
    - $ref: '#/definitions/currentJsonSchema'
    - $ref: '#/definitions/futureJsonSchema'
    - $ref: '#/definitions/customJsonSchema'
    - propertyNames:
        anyOf:
        - $ref: '#/definitions/validPropertyNames'
        - enum: [actions, model, type, description, deprecated, examples, defaultOut, transform, transformOut, compute,
          computeOut, readOnly, writeOnce]
        - enum:
            $data: '/customValidationNames'
  # Only applies this to top-level models
  topLevelModel:
    allOf:
    - $ref: '#/definitions/generalObjectSchema'
    - propertyNames:
        allOf:
        - anyOf:
          - $ref: '#/definitions/validPropertyNames'
          - enum: [actions]
        - not:
            enum: [default]
      # Must have a `required` property
      required: [required, properties]
      properties:
        actions:
          $ref: '#/definitions/actionsProperty'
        # `required` property must at least contain `id`
        required:
          contains:
            enum: [id]
        # Must have an `id`
        properties:
          required: [id]
        # When specified, type must be 'object'
        type:
          const:
            object
  # Only applies this to models attributes, including nested models
  attributeSchema:
    allOf:
    - $ref: '#/definitions/generalObjectSchema'
    - propertyNames:
        anyOf:
        - $ref: '#/definitions/validPropertyNames'
        - enum: [model, defaultOut, transform, transformOut, compute, computeOut, readOnly, writeOnce]
        - enum:
            $data: '/customValidationNames'
      properties:
        # Recursively applied to array members
        items:
          $ref: '#/definitions/attributeSchema'
        readOnly:
          type: boolean
        writeOnce:
          type: boolean
      # Only for nested models
      if:
        required: [model]
      then:
        $ref: '#/definitions/nestedModel'
  # Only applies this to nested models
  nestedModel:
    # Restrict the possible properties
    propertyNames:
      enum: [model, type, description, deprecated, examples, default, defaultOut, tranform, transformOut, compute,
      computeOut, actions, readOnly, writeOnce]
    # Must have a `model` property
    required: [model]
    properties:
      # Refers to a top-level model name
      model:
        type: string
        enum:
          $data: '/modelNames'
  # Validation of `actions` property, e.g. `actions: [find, createOne]`
  # This property restricts which actions a specific model can perform
  actionsProperty:
    type: array
    uniqueItems: true
    items:
      type: string
      enum: [find, findOne, create, createOne, replace, replaceOne, update, updateOne, upsert, upsertOne, delete, deleteOne]
    # One can only choose between find (conceptually "findOne" + "findMany") and "findOne". Same thing for other actions
    not:
      anyOf:
      - allOf: [contains: {enum: [find    ]}, contains: {enum: [findOne   ]}]
      - allOf: [contains: {enum: [delete  ]}, contains: {enum: [deleteOne ]}]
      - allOf: [contains: {enum: [update  ]}, contains: {enum: [updateOne ]}]
      - allOf: [contains: {enum: [upsert  ]}, contains: {enum: [upsertOne ]}]
      - allOf: [contains: {enum: [replace ]}, contains: {enum: [replaceOne]}]
      - allOf: [contains: {enum: [create  ]}, contains: {enum: [createOne ]}]
    # find or findOne has to be defined, because GraphQL requires at least one query action
    contains: {enum: [find, findOne]}
  # idl.helpers|variables.library
  librariesProperty:
    type: array
    items:
      # Libraries like Lodash or underscore.string are objects that can be used as functions as well
      typeof: [function, object]
  # JSL can either be a function or a string '(...)'
  jsl:
    anyOf:
    - typeof: function
    - typeof: string
      pattern: '^\s*\(.*\)\s*$'
  # Value of schema.type from JSON schema
  jsonSchemaType:
    oneOF:
    - type: string
      enum: [string, number, integer, boolean, null, object, array]
    - type: array
      items:
        $ref: '#/definitions/jsonSchemaType'
  # Base list of valid property names
  # We are more restrictive than the JSON schema and forbid any unknown property name
  # The goal is to avoid typos and mistakes. Custom properties can be added as `x-*`
  validPropertyNames:
    anyOf:
    - enum: [
      # Standard JSON schema properties
      $id, $schema, $ref, title, description, default, multipleOf, maximum, exclusiveMaximum, minimum,
      exclusiveMinimum, maxLength, minLength, pattern, items, maxItems, minItems, uniqueItems,
      contains, maxProperties, minProperties, required, additionalProperties, definitions, properties,
      patternProperties, dependencies, propertyNames, const, enum, type, format, allOf, anyOf, oneOf, not,
      # Future standard JSON schema properties
      examples, formatMaximum, formatMinimum, formatExclusiveMinimum, formatExclusiveMaximum, if, then, else,
      # Properties specific to this project
      deprecated,
    ]
    # Users can define anything under property named x-*
    - pattern: '^x-*'
  validModelName:
    allOf:
    # Valid GraphQL identifier name, regular expression taken from spec
    # Additional restriction: lowercase-only
    - pattern: '^[_a-z][_0-9a-z]*$'
    # Should not start with __ as it is reserved for GraphQL introspection types
    - not:
        pattern: '^__'
    # Those attributes are automatically added, so must not be specified
    - not:
        enum: [created_time, updated_time, created_by, updated_by]
  # Reuse standard JSON schema as a base
  # This is JSON schema v6, as YAML
  # The spec is currently in draft (only v4 is currently official)
  currentJsonSchema:
    definitions:
      schemaArray:
        type: array
        minItems: 1
        items:
          $ref: '#/definitions/generalSchema'
      nonNegativeInteger:
        type: integer
        minimum: 0
      nonNegativeIntegerDefault0:
        allOf:
          - $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeInteger'
          - default: 0
      simpleTypes:
        enum:
          - array
          - boolean
          - integer
          - 'null'
          - number
          - object
          - string
      stringArray:
        type: array
        items:
          type: string
        uniqueItems: true
        default: []
    type:
      - object
      - boolean
    properties:
      $id:
        type: string
        format: uri-reference
      $schema:
        type: string
        format: uri
      $ref:
        type: string
        format: uri-reference
      title:
        type: string
      description:
        type: string
      default: {}
      multipleOf:
        type: number
        exclusiveMinimum: 0
      maximum:
        type: number
      exclusiveMaximum:
        type: number
      minimum:
        type: number
      exclusiveMinimum:
        type: number
      maxLength:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeInteger'
      minLength:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeIntegerDefault0'
      pattern:
        type: string
        format: regex
      additionalItems:
        $ref: '#/definitions/generalSchema'
      items:
        anyOf:
          - $ref: '#/definitions/generalSchema'
          - $ref: '#/definitions/currentJsonSchema/definitions/schemaArray'
        default: {}
      maxItems:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeInteger'
      minItems:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeIntegerDefault0'
      uniqueItems:
        type: boolean
        default: false
      contains:
        $ref: '#/definitions/generalSchema'
      maxProperties:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeInteger'
      minProperties:
        $ref: '#/definitions/currentJsonSchema/definitions/nonNegativeIntegerDefault0'
      required:
        $ref: '#/definitions/currentJsonSchema/definitions/stringArray'
      additionalProperties:
        $ref: '#/definitions/generalSchema'
      definitions:
        type: object
        additionalProperties:
          $ref: '#/definitions/generalSchema'
        default: {}
      properties:
        type: object
        additionalProperties:
          $ref: '#/definitions/generalSchema'
        default: {}
      patternProperties:
        type: object
        additionalProperties:
          $ref: '#/definitions/generalSchema'
        default: {}
      dependencies:
        type: object
        additionalProperties:
          anyOf:
            - $ref: '#/definitions/generalSchema'
            - $ref: '#/definitions/currentJsonSchema/definitions/stringArray'
      propertyNames:
        $ref: '#/definitions/generalSchema'
      const: {}
      enum:
        type: array
        minItems: 1
        uniqueItems: true
      type:
        anyOf:
          - $ref: '#/definitions/currentJsonSchema/definitions/simpleTypes'
          - type: array
            items:
              $ref: '#/definitions/currentJsonSchema/definitions/simpleTypes'
            minItems: 1
            uniqueItems: true
      format:
        type: string
      allOf:
        $ref: '#/definitions/currentJsonSchema/definitions/schemaArray'
      anyOf:
        $ref: '#/definitions/currentJsonSchema/definitions/schemaArray'
      oneOf:
        $ref: '#/definitions/currentJsonSchema/definitions/schemaArray'
      not:
        $ref: '#/definitions/generalSchema'
    default: {}
  # Future JSON standard
  futureJsonSchema:
    properties:
      examples:
        type: array
        items:
          type: string
      formatMaximum:
        type: string
      formatMinimum:
        type: string
      formatExclusiveMaximum:
        type: boolean
      formatExclusiveMinimum:
        type: boolean
      if:
        $ref: '#/definitions/generalSchema'
      then:
        $ref: '#/definitions/generalSchema'
      else:
        $ref: '#/definitions/generalSchema'
    dependencies:
      formatExclusiveMinimum: [formatMinimum]
      formatExclusiveMaximum: [formatMaximum]
      if: [then]
      then: [if]
      else: [then]
  # Our additions to JSON schema
  customJsonSchema:
    properties:
      # Used to indicate an attribute is deprecated, and why
      deprecated:
        type: string
      # All spec-defined formats are allowed. We are stricter than the spec, as custom formats are forbidden.
      format:
        enum: [regex, date-time, date, time, email, hostname, ipv4, ipv6, uri, uri-reference, json-pointer,
          relative-json-pointer]
